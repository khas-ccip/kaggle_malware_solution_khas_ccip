import pandas as pd
import numpy as np
import json
from sklearn.model_selection import train_test_split
from feature_engine import categorical_encoders, missing_data_imputers, outlier_removers
import gc
#import matplotlib.pyplot as plt

# To read directory structure from SETTINGS.json file
with open('./../SETTINGS.json', 'r') as f:
	settings = json.load(f)

#Constant objects are declared
print('START...')
training_file_name = '.' + settings['RAW_DATA_DIR'] + 'raw/' + 'train.csv'
test_file_name = '.' + settings['RAW_DATA_DIR'] + 'raw/' + 'test.csv'

dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        'HasDetections':                                        'int8'
        } # To reduce memory usage, change dtypes with available types

#Read train.csv and test.csv both        
dataset = pd.read_csv(training_file_name,dtype=dtypes,low_memory=False)
original_testset = pd.read_csv(test_file_name,dtype=dtypes,low_memory=False)

original_testset['HasDetections'] = -1 * np.ones((len(original_testset), ), np.int8) # add HasDetections column containing -1 to test dataframe for data consistency
all_dataset = pd.concat([dataset, original_testset], axis=0) # concatenate train and test dataframes

del dataset, original_testset
gc.collect() # garbage collection for efficient memory usage

total = all_dataset.isnull().sum().sort_values(ascending = False)
percent = (all_dataset.isnull().sum()/all_dataset.isnull().count()*100).sort_values(ascending = False)
missing_data  = pd.concat([total, percent], axis=1, keys=['Total', 'Percent']) # calculate missing values percentages for each column
missing_cols = list(missing_data[missing_data.Percent > 70].index) # find columns containing missing values greater than 70%
print(missing_cols)
"""
['PuaMode',
 'Census_ProcessorClass',
 'DefaultBrowsersIdentifier',
 'Census_IsFlightingInternal',
 'Census_InternalBatteryType']
"""
all_dataset.drop(labels=missing_cols, axis='columns', inplace=True) # drop columns containing missing values greater than 70%


#Missing value Imputation & Categorical Feature Transformation Part

for col in all_dataset.columns: 
    if all_dataset[col].dtype.name == 'category':
        all_dataset[col] = all_dataset[col].astype('object') # change category to object to use feature_engine library for categorical values

#find categorical & numeric column names, except MachineIdentifier and HasDetections columns 
cat_names = list(all_dataset.select_dtypes(include=['object']).columns)
dropped_machine_id_cat_names = cat_names[2:]
cont_names = [col for col in all_dataset.columns if all_dataset[col].dtype.name != 'object']
dropped_targets_cont_names = cont_names[:-1]

print(dropped_machine_id_cat_names)
"""
['EngineVersion',
 'AppVersion',
 'AvSigVersion',
 'Platform',
 'Processor',
 'OsVer',
 'OsPlatformSubRelease',
 'OsBuildLab',
 'SkuEdition',
 'SmartScreen',
 'Census_MDC2FormFactor',
 'Census_DeviceFamily',
 'Census_PrimaryDiskTypeName',
 'Census_ChassisTypeName',
 'Census_PowerPlatformRoleName',
 'Census_OSVersion',
 'Census_OSArchitecture',
 'Census_OSBranch',
 'Census_OSEdition',
 'Census_OSSkuName',
 'Census_OSInstallTypeName',
 'Census_OSWUAutoUpdateOptionsName',
 'Census_GenuineStateName',
 'Census_ActivationChannel',
 'Census_FlightRing']
"""

print(dropped_targets_cont_names)
"""
['IsBeta',
 'RtpStateBitfield',
 'IsSxsPassiveMode',
 'AVProductStatesIdentifier',
 'AVProductsInstalled',
 'AVProductsEnabled',
 'HasTpm',
 'CountryIdentifier',
 'CityIdentifier',
 'OrganizationIdentifier',
 'GeoNameIdentifier',
 'LocaleEnglishNameIdentifier',
 'OsBuild',
 'OsSuite',
 'IsProtected',
 'AutoSampleOptIn',
 'SMode',
 'IeVerIdentifier',
 'Firewall',
 'UacLuaenable',
 'Census_OEMNameIdentifier',
 'Census_OEMModelIdentifier',
 'Census_ProcessorCoreCount',
 'Census_ProcessorManufacturerIdentifier',
 'Census_ProcessorModelIdentifier',
 'Census_PrimaryDiskTotalCapacity',
 'Census_SystemVolumeTotalCapacity',
 'Census_HasOpticalDiskDrive',
 'Census_TotalPhysicalRAM',
 'Census_InternalPrimaryDiagonalDisplaySizeInInches',
 'Census_InternalPrimaryDisplayResolutionHorizontal',
 'Census_InternalPrimaryDisplayResolutionVertical',
 'Census_InternalBatteryNumberOfCharges',
 'Census_OSBuildNumber',
 'Census_OSBuildRevision',
 'Census_OSInstallLanguageIdentifier',
 'Census_OSUILocaleIdentifier',
 'Census_IsPortableOperatingSystem',
 'Census_IsFlightsDisabled',
 'Census_ThresholdOptIn',
 'Census_FirmwareManufacturerIdentifier',
 'Census_FirmwareVersionIdentifier',
 'Census_IsSecureBootEnabled',
 'Census_IsWIMBootEnabled',
 'Census_IsVirtualDevice',
 'Census_IsTouchEnabled',
 'Census_IsPenCapable',
 'Census_IsAlwaysOnAlwaysConnectedCapable',
 'Wdft_IsGamer',
 'Wdft_RegionIdentifier']
"""

testset = all_dataset[all_dataset.HasDetections == -1]
trainset = all_dataset[all_dataset.HasDetections != -1] # seperate original train and test sets using -1 sentinel value

del all_dataset
gc.collect()

cat_imputer = missing_data_imputers.FrequentCategoryImputer(variables=dropped_machine_id_cat_names) # missing value imputer for categorical values (the most frequent value)
cont_imputer = missing_data_imputers.MeanMedianImputer(variables=dropped_targets_cont_names) # missing value imputer for numeric values (median value)

cat_imputer.fit(trainset)
trainset = cat_imputer.transform(trainset) # cat_imputer fit and transform for train set
print(trainset.head())

testset = cat_imputer.transform(testset) # cat_imputer (only) transform for test set 
print(testset.head())

rare_cat_enc = categorical_encoders.RareLabelCategoricalEncoder(variables=dropped_machine_id_cat_names)
rare_cat_enc.fit(trainset)
trainset = rare_cat_enc.transform(trainset) # find rare (using a threshold value) categorical values from train set and replace these values with 'rare', this technique is useful to prevent overfitting because of CountFrequencyCategoricalEncoder
testset = rare_cat_enc.transform(testset) # rare_cat_enc (only) transform for test set

cf_cat_enc = categorical_encoders.CountFrequencyCategoricalEncoder(encoding_method='frequency', variables=dropped_machine_id_cat_names)
cf_cat_enc.fit(trainset)
trainset = cf_cat_enc.transform(trainset) # Convert all categorical features to normalized frequency values
testset = cf_cat_enc.transform(testset) # transform for test set

cont_imputer.fit(trainset)
trainset = cont_imputer.transform(trainset) # ift and transform for cont_imputer on train set
print(trainset.head())
testset = cont_imputer.transform(testset) # (only) transform for cont_imputer on test set
print(testset.head())

trainset.to_csv('.' + settings['TRAIN_DATA_CLEAN_PATH'], index=False)
testset.to_csv('.' + settings['TEST_DATA_CLEAN_PATH'], index=False) # Before feature selection the last version of train and test sets are written to paths

#LOFO Feature Importance & Feature Selection

from sklearn.model_selection import KFold
import xgboost as xgb

xgbm = xgb.XGBClassifier()

sample_df = trainset.sample(frac=0.001, random_state=0) # Due to huge execution time, a relatively subset from original train set is used for obtaining feature importance
cv = KFold(n_splits=5, shuffle=False, random_state=0)
print(sample_df.shape)

from lofo.lofo_importance import LOFOImportance, plot_importance # feature importance library LOFO

target = "HasDetections"
features = [col for col in sample_df.drop(['MachineIdentifier', 'ProductName'], axis='columns').columns if col != target]

lofo = LOFOImportance(sample_df, features, target, cv=cv, scoring="roc_auc", model=xgbm)

importance_df = lofo.get_importance()
print(importance_df.head())

plot_importance(importance_df, figsize=(12, 20)) # plot feature importance values oredered in descending

to_keep_cols = list(importance_df['feature'].values[:30]) # get the first 30 important features from importance_df (this value is set 30 from plot, just a decision)
to_keep_cols += ["HasDetections", 'MachineIdentifier']
print(to_keep_cols)
"""
['SmartScreen',
 'Wdft_IsGamer',
 'AVProductStatesIdentifier',
 'Census_HasOpticalDiskDrive',
 'EngineVersion',
 'Census_PrimaryDiskTotalCapacity',
 'OsBuild',
 'Census_InternalPrimaryDiagonalDisplaySizeInInches',
 'Wdft_RegionIdentifier',
 'Census_ChassisTypeName',
 'IeVerIdentifier',
 'Census_SystemVolumeTotalCapacity',
 'Census_TotalPhysicalRAM',
 'Census_OSWUAutoUpdateOptionsName',
 'Census_OSBuildRevision',
 'Processor',
 'AppVersion',
 'Platform',
 'Census_OSEdition',
 'Census_FirmwareManufacturerIdentifier',
 'OsSuite',
 'Census_OSBuildNumber',
 'Census_InternalPrimaryDisplayResolutionHorizontal',
 'Census_GenuineStateName',
 'Census_OSBranch',
 'OsBuildLab',
 'Census_OSVersion',
 'Firewall',
 'HasTpm',
 'Census_IsAlwaysOnAlwaysConnectedCapable',
 'HasDetections',
 'MachineIdentifier']
"""

training_df, val_df = train_test_split(trainset, test_size=0.1, stratify=trainset['HasDetections']) # 10% of the train set is used for holdout validation
training_df[to_keep_cols].to_csv('.' + settings['TRAIN_DATA_FINAL_PATH'], index=False)
val_df[to_keep_cols].to_csv('.' + settings['VAL_DATA_FINAL_PATH'], index=False)
testset[to_keep_cols].to_csv('.' + settings['TEST_DATA_FINAL_PATH'], index=False) # write final version of the datasets to the path

print('STOP...')
